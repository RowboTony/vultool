package vault

import (
	"encoding/hex"
	"sort"
	"strings"

	"github.com/btcsuite/btcd/btcutil/base58"
	"github.com/btcsuite/btcd/btcutil/hdkeychain"
	"github.com/btcsuite/btcd/chaincfg"
	"github.com/decred/dcrd/dcrec/secp256k1/v4"
	"github.com/rowbotony/vultool/internal/types"
)

// PathAddress represents a derivation path and the resulting address
type PathAddress struct {
	Chain       string `json:"chain"`
	Ticker      string `json:"ticker"`
	Address     string `json:"address"`
	DerivePath  string `json:"derive_path"`
	Description string `json:"description"`
	Purpose     string `json:"purpose"`
}

// DerivePathAddresses derives addresses for all common derivation paths from a vault
func DerivePathAddresses(vaultInfo *VaultInfo, pathsByChain map[types.SupportedChain][]types.DerivationPath, maxCount int) []PathAddress {
	var results []PathAddress

	// Process ECDSA-based chains (Bitcoin, Ethereum, etc.)
	if vaultInfo.PublicKeyECDSA != "" {
		results = append(results, deriveECDSAPathAddresses(vaultInfo.PublicKeyECDSA, vaultInfo.HexChainCode, pathsByChain)...)
	}

	// Process EdDSA-based chains (Solana, etc.)
	if vaultInfo.PublicKeyEDDSA != "" {
		results = append(results, deriveEdDSAPathAddresses(vaultInfo.PublicKeyEDDSA, pathsByChain)...)
	}

	// Sort by chain and path for consistent output
	sort.Slice(results, func(i, j int) bool {
		if results[i].Chain != results[j].Chain {
			return results[i].Chain < results[j].Chain
		}
		return results[i].DerivePath < results[j].DerivePath
	})

	// Apply count limit if specified
	if maxCount > 0 && len(results) > maxCount {
		results = results[:maxCount]
	}

	return results
}

// deriveECDSAPathAddresses derives addresses for ECDSA-based chains using their paths
func deriveECDSAPathAddresses(pubKeyHex string, chainCodeHex string, pathsByChain map[types.SupportedChain][]types.DerivationPath) []PathAddress {
	var results []PathAddress

	// Define chain mappings for ECDSA chains
	echainMappings := map[types.SupportedChain]struct {
		chain  string
		ticker string
	}{
		types.ChainBitcoin:     {"Bitcoin", "BTC"},
		types.ChainBitcoinCash: {"Bitcoin-Cash", "BCH"},
		types.ChainLitecoin:    {"Litecoin", "LTC"},
		types.ChainDogecoin:    {"Dogecoin", "DOGE"},
		types.ChainDash:        {"Dash", "DASH"},
		types.ChainZcash:       {"Zcash", "ZEC"},
		types.ChainEthereum:    {"Ethereum", "ETH"},
		types.ChainBSC:         {"BSC", "BSC"},
		types.ChainAvalanche:   {"Avalanche", "AVAX"},
		types.ChainPolygon:     {"Polygon", "MATIC"},
		types.ChainCronosChain: {"CronosChain", "CRO"},
		types.ChainArbitrum:    {"Arbitrum", "ETH"},
		types.ChainOptimism:    {"Optimism", "ETH"},
		types.ChainBase:        {"Base", "ETH"},
		types.ChainBlast:       {"Blast", "ETH"},
		types.ChainZksync:      {"Zksync", "ETH"},
		types.ChainThorChain:   {"THORChain", "RUNE"},
	}

	// Process all ECDSA chains
	for chainType, mapping := range echainMappings {
		if paths, ok := pathsByChain[chainType]; ok {
			for _, path := range paths {
				addr := deriveECDSAAddressForPath(pubKeyHex, chainCodeHex, path.Path, mapping.chain, mapping.ticker)
				if addr != "" && !strings.HasPrefix(addr, "error:") {
					results = append(results, PathAddress{
						Chain:       mapping.chain,
						Ticker:      mapping.ticker,
						Address:     addr,
						DerivePath:  path.Path,
						Description: path.Description,
						Purpose:     path.Purpose,
					})
				}
			}
		}
	}

	return results
}

// deriveEdDSAPathAddresses derives addresses for EdDSA-based chains using their paths
func deriveEdDSAPathAddresses(pubKeyHex string, pathsByChain map[types.SupportedChain][]types.DerivationPath) []PathAddress {
	var results []PathAddress

	// Process Solana paths
	if paths, ok := pathsByChain[types.ChainSolana]; ok {
		for _, path := range paths {
			// For Solana, we currently just use the master key directly (no HD derivation)
			// In a future version, we could implement proper ed25519 HD derivation
			addr := deriveSolanaAddress(pubKeyHex)
			if addr != "" {
				results = append(results, PathAddress{
					Chain:       "Solana",
					Ticker:      "SOL",
					Address:     addr,
					DerivePath:  path.Path,
					Description: path.Description,
					Purpose:     path.Purpose,
				})
			}
		}
	}

	// Process SUI paths
	if paths, ok := pathsByChain[types.ChainSUI]; ok {
		for _, path := range paths {
			// For SUI, we currently use hex encoding as a placeholder
			// In a future version, we could implement proper SUI address derivation
			addr := deriveSUIAddress(pubKeyHex)
			if addr != "" {
				results = append(results, PathAddress{
					Chain:       "SUI",
					Ticker:      "SUI",
					Address:     addr,
					DerivePath:  path.Path,
					Description: path.Description,
					Purpose:     path.Purpose,
				})
			}
		}
	}

	return results
}

// PLACEHOLDER - This function would call address derivation logic from address_derivation.go
// For now, this is not implemented and would need to use common functions
